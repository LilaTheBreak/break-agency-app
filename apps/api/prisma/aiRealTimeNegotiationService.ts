import prisma from '../../lib/prisma.js';
import { aiClient } from './aiClient.js';
import { applyPersona } from './persona/personaApplier.js';

const realTimePrompt = (context: {
  history: string;
  ourLastOffer: number;
  brandReply: string;
  policy: any;
}) => `
You are an autonomous AI negotiation agent in the middle of a negotiation. Analyze the brand's latest reply and decide the next move.

**Our Last Offer:** Â£${context.ourLastOffer}
**Agent Policy:**
- Negotiation Style: ${context.policy.negotiationStyle}
- Auto-Send Replies: ${!context.policy.sandboxMode}

**Full Conversation History:**
---
${context.history}
---

**Brand's Latest Reply:**
"${context.brandReply}"

**Instructions:**
1.  **determineIntent**: Analyze the brand's reply. What is their intent? ('ACCEPT', 'COUNTER_OFFER', 'REJECT', 'CLARIFY').
2.  **shouldEscalate**: Based on their intent and tone, should this be escalated to a human? (e.g., if they are angry or the request is complex).
3.  **runAdaptiveStrategy**: If not escalating, propose the next move. If they countered, meet them in the middle or hold firm based on policy. If they accepted, confirm the deal.
4.  **generateNextEmail**: Draft a subject and body for the response based on your decision.

**JSON Output Schema:**
{
  "analysis": {
    "brandIntent": "'ACCEPT' | 'COUNTER_OFFER' | 'REJECT' | 'CLARIFY'",
    "brandCounterFee": "number | null",
    "sentiment": "'positive' | 'neutral' | 'negative'"
  },
  "escalateToHuman": "boolean",
  "escalationReason": "string | null",
  "nextMove": {
    "decision": "'COUNTER' | 'ACCEPT' | 'HOLD_FIRM'",
    "justification": "string",
    "nextOffer": "number | null"
  },
  "draft": { "subject": "string", "body": "string" }
}
`;

/**
 * The main orchestrator for handling a brand's reply in real-time.
 * @param sessionId - The ID of the active NegotiationSession.
 * @param brandReplyBody - The text of the brand's latest email.
 */
export async function handleBrandReply(sessionId: string, brandReplyBody: string) {
  // 1. Load Negotiation State
  const session = await prisma.negotiationSession.findUnique({
    where: { id: sessionId },
    include: {
      messages: { orderBy: { createdAt: 'asc' } },
      user: { include: { agentPolicy: true, personaProfile: true } },
    },
  });
  if (!session || !session.user) throw new Error('Negotiation session or user context not found.');

  const history = session.messages.map(m => `${m.sender}: ${m.body}`).join('\n\n');
  const ourLastOffer = (session.aiCounterOffer as any)?.value || 0;

  // 2. Run AI analysis and get next move
  const result = await aiClient.json(realTimePrompt({
    history,
    ourLastOffer,
    brandReply: brandReplyBody,
    policy: session.user.agentPolicy,
  })) as any;

  // 3. Update Session State
  await prisma.negotiationSession.update({
    where: { id: sessionId },
    data: {
      aiLastBrandIntent: result.analysis.brandIntent,
      aiLastBrandFee: result.analysis.brandCounterFee,
      aiAutoCounter: result.nextMove,
    },
  });

  // 4. Handle Escalation
  if (result.escalateToHuman) {
    console.log(`[REAL-TIME NEGOTIATOR] Escalating session ${sessionId}. Reason: ${result.escalationReason}`);
    // Add to a human review queue or send a Slack alert
    return;
  }

  // 5. Auto-Send Reply If Allowed
  const finalBody = session.user.personaProfile
    ? await applyPersona(result.draft.body, session.user.personaProfile)
    : result.draft.body;

  const shouldAutoSend = !session.user.agentPolicy?.sandboxMode && session.user.agentPolicy?.autoSendNegotiation;

  await prisma.negotiationMessage.create({
    data: {
      sessionId,
      sender: shouldAutoSend ? 'ai_sent' : 'ai_draft',
      subject: result.draft.subject,
      body: finalBody,
      isAutoGenerated: true,
      analysis: result.analysis,
    },
  });

  console.log(`[REAL-TIME NEGOTIATOR] Processed reply for session ${sessionId}. Next move: ${result.nextMove.decision}`);
}