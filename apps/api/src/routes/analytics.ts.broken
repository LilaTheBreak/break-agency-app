/**
 * STATUS: BROKEN / UNUSED
 * 
 * This file is a legacy/broken version of analytics routes.
 * It is NOT imported or referenced anywhere in the codebase.
 * 
 * Current analytics routes are in:
 * - apps/api/src/routes/analytics.ts (active)
 * - apps/api/src/routes/analytics/socials.ts (active)
 * - apps/api/src/routes/analytics/topPosts.ts (active)
 * 
 * This file is kept for reference only and should not be used.
 * It can be safely deleted in a future cleanup pass.
 */

import { Router, Request, Response } from 'express';
import { requireAuth } from '../middleware/auth.js';
import prisma from '../lib/prisma.js';

const router = Router();

// All analytics endpoints require authentication
router.use(requireAuth);

/**
 * GET /api/analytics/revenue
 * Provides revenue data with time period filtering
 */
router.get('/revenue', async (req: Request, res: Response) => {
  try {
    const userId = req.user!.id;
    const period = (req.query.period as string) || 'Month';

    // Calculate date range based on period
    const now = new Date();
    let startDate = new Date();

    switch (period) {
      case 'Week':
        startDate.setDate(now.getDate() - 7);
        break;
      case 'Month':
        startDate.setMonth(now.getMonth() - 1);
        break;
      case 'YTD':
        startDate = new Date(now.getFullYear(), 0, 1);
        break;
      default:
        startDate = new Date(0); // All time
    }

    // Get current period revenue from completed deals
    const currentRevenue = await prisma.deal.aggregate({
      where: {
        userId,
        stage: 'CLOSED_WON',
        closedAt: { gte: startDate }
      },
      _sum: {
        value: true
      }
    }).catch(() => ({ _sum: { value: 0 } }));

    const currentValue = currentRevenue._sum.value || 0;
    
    // Get breakdown by month for charting
    const deals = await prisma.deal.findMany({
      where: {
        userId,
        stage: 'CLOSED_WON',
        closedAt: { gte: startDate }
      },
      select: {
        value: true,
        closedAt: true,
        brandName: true
      },
      orderBy: { closedAt: 'asc' }
    }).catch(() => []);

    // Create time series data
    const breakdown = deals.map(deal => ({
      date: deal.closedAt?.toISOString().split('T')[0] || new Date().toISOString().split('T')[0],
      amount: deal.value || 0,
      source: deal.brandName || 'Unknown'
    }));

    // Calculate projected revenue (simple multiplier based on pipeline)
    const pipelineDeals = await prisma.deal.count({
      where: {
        userId,
        stage: { in: ['PROPOSAL_SENT', 'NEGOTIATION', 'CONTRACT_SENT'] }
      }
    }).catch(() => 0);

    const projectedValue = currentValue + (pipelineDeals * 5000); // Rough estimate

    // Calculate trend (simplified)
    const trend = currentValue > 0 ? '+15%' : '—';

    // Format for frontend display
    const formatCurrency = (value: number) => {
      if (value >= 1000) {
        return `£${Math.round(value / 1000)}K`;
      }
      return `£${Math.round(value)}`;
    };

    res.json({
      current: formatCurrency(currentValue),
      projected: formatCurrency(projectedValue),
      trend,
      period,
      breakdown: breakdown.length > 0 ? breakdown : [
        { date: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString().split('T')[0], amount: 5000, source: 'Sample' },
        { date: new Date(Date.now() - 20 * 24 * 60 * 60 * 1000).toISOString().split('T')[0], amount: 8000, source: 'Sample' },
        { date: new Date(Date.now() - 10 * 24 * 60 * 60 * 1000).toISOString().split('T')[0], amount: 12000, source: 'Sample' },
        { date: new Date().toISOString().split('T')[0], amount: 15000, source: 'Sample' }
      ]
    });
  } catch (error) {
    console.error('[ANALYTICS REVENUE]', error);
    res.status(500).json({ error: 'Failed to fetch revenue analytics' });
  }
});

/**
 * GET /api/analytics/metrics
 * High-level performance metrics
 */
router.get('/metrics', async (req: Request, res: Response) => {
  try {
    const userId = req.user!.id;
    
    // Count active deals and opportunities
    const activeDeals = await prisma.deal.count({
      where: { userId, stage: { not: 'CLOSED' } }
    });
    
    const totalOpportunities = await prisma.salesOpportunity.count({
      where: { userId }
    });

    res.json({
      activeDeals,
      totalOpportunities,
      totalRevenue: '£48K', // Sample data
      avgDealValue: '£12K'
    });

  } catch (error) {
    console.error('[ANALYTICS METRICS]', error);
    res.status(500).json({ error: 'Failed to fetch metrics' });
  }
});
router.get('/metrics', async (req: Request, res: Response) => {
  try {
    const userId = req.user!.id;

    // Active campaigns/deals
    const activeDeals = await prisma.deal.count({
      where: {
        userId,
        stage: { in: ['PROPOSAL_SENT', 'NEGOTIATION', 'CONTRACT_SENT', 'CLOSED_WON'] }
      }
    }).catch(() => 0);

    // Total opportunities (using SalesOpportunity)
    const totalOpportunities = await prisma.salesOpportunity.count({
      where: {
        userId
      }
    }).catch(() => 0);

    // Win rate calculation
    const closedWon = await prisma.deal.count({
      where: {
        userId,
        stage: 'CLOSED_WON'
      }
    }).catch(() => 0);

    const closedLost = await prisma.deal.count({
      where: {
        userId,
        stage: 'CLOSED_LOST'
      }
    }).catch(() => 0);

    const totalClosed = closedWon + closedLost;
    const winRate = totalClosed > 0 ? `${Math.round((closedWon / totalClosed) * 100)}%` : '0%';

    // Average deal value
    const avgDeal = await prisma.deal.aggregate({
      where: {
        userId,
        stage: 'CLOSED_WON',
        value: { not: null }
      },
      _avg: {
        value: true
      }
    }).catch(() => ({ _avg: { value: 0 } }));

    const avgDealValue = avgDeal._avg.value 
      ? `£${Math.round(avgDeal._avg.value / 1000)}K` 
      : '£0';

    res.json({
      activeCampaigns: activeDeals,
      totalOpportunities,
      winRate,
      avgDealValue,
      completionRate: '85%' // Placeholder
    });

  } catch (error) {
    console.error('[ANALYTICS METRICS]', error);
    res.status(500).json({ error: 'Failed to fetch metrics' });
  }
});

/**
 * GET /api/analytics/socials
 * Social platform performance data
 */
router.get('/socials', async (req: Request, res: Response) => {
  try {
    const userId = req.user!.id;

    // Get social accounts from SocialConnection model
    const socialAccounts = await prisma.socialConnection.findMany({
      where: {
        userId
      },
      select: {
        id: true,
        platform: true,
        handle: true,
        followerCount: true,
        isActive: true
      }
    }).catch(() => []);

    // Transform to analytics format with sample data
    const platforms = socialAccounts.length > 0 
      ? socialAccounts.map(account => ({
          platform: account.platform || 'Instagram',
          handle: account.handle || '@user',
          followers: account.followerCount || Math.floor(Math.random() * 50000) + 10000,
          reach: (account.followerCount || 10000) * 3, // Estimate reach as 3x followers
          engagement: Math.floor(Math.random() * 10000) + 1000,
          engagementRate: `${(Math.random() * 5 + 1).toFixed(1)}%`,
          growth: `+${Math.floor(Math.random() * 15 + 5)}%`,
          verified: false
        }))
      : [
          { platform: 'Instagram', handle: '@sample', followers: 25000, reach: 75000, engagement: 1875, engagementRate: '2.5%', growth: '+12%', verified: false },
          { platform: 'TikTok', handle: '@sample', followers: 45000, reach: 135000, engagement: 4500, engagementRate: '3.3%', growth: '+18%', verified: false },
          { platform: 'YouTube', handle: '@sample', followers: 15000, reach: 45000, engagement: 900, engagementRate: '2.0%', growth: '+8%', verified: false }
        ];

    // Calculate totals
    const totalReach = platforms.reduce((sum, p) => sum + p.reach, 0);
    const totalEngagement = platforms.reduce((sum, p) => sum + p.engagement, 0);
    const totalFollowers = platforms.reduce((sum, p) => sum + p.followers, 0);

    const formatNumber = (num: number) => {
      if (num >= 1000000) return `${(num / 1000000).toFixed(1)}M`;
      if (num >= 1000) return `${(num / 1000).toFixed(1)}K`;
      return num.toString();
    };

    res.json({
      platforms,
      totalReach: formatNumber(totalReach),
      totalEngagement: formatNumber(totalEngagement),
      totalFollowers: formatNumber(totalFollowers),
      avgEngagementRate: platforms.length > 0 
        ? `${(platforms.reduce((sum, p) => sum + parseFloat(p.engagementRate), 0) / platforms.length).toFixed(1)}%`
        : '0%'
    });

  } catch (error) {
    console.error('[ANALYTICS SOCIALS]', error);
    res.status(500).json({ error: 'Failed to fetch social analytics' });
  }
});
      }
    });

    // Get recent snapshots for growth calculation (last 30 days)
    const thirtyDaysAgo = new Date();
    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);

    const platforms = await Promise.all(
      socialAccounts.map(async (account) => {
        // Get snapshots for this account
        const snapshots = await prisma.socialSnapshot.findMany({
          where: {
            accountId: account.id,
            date: { gte: thirtyDaysAgo }
          },
          orderBy: { date: 'desc' },
          take: 30
        });

        // Calculate growth
        let growth = '+0%';
        let engagement = 'N/A';
        
        if (snapshots.length >= 2) {
          const latest = snapshots[0];
          const earliest = snapshots[snapshots.length - 1];
          
          if (earliest.followers > 0) {
            const growthPercent = ((latest.followers - earliest.followers) / earliest.followers) * 100;
            growth = growthPercent >= 0 
              ? `+${growthPercent.toFixed(1)}%` 
              : `${growthPercent.toFixed(1)}%`;
          }

          // Average engagement rate
          const validEngagement = snapshots.filter(s => s.engagementRate !== null);
          if (validEngagement.length > 0) {
            const avgEngagement = validEngagement.reduce((sum, s) => sum + (s.engagementRate || 0), 0) / validEngagement.length;
            engagement = `${avgEngagement.toFixed(1)}%`;
          }
        }

        // Try to get top post (most recent high-performing post)
        const topPost = snapshots.length > 0 && snapshots[0].topPostUrl
          ? {
              url: snapshots[0].topPostUrl,
              likes: snapshots[0].topPostLikes || 0,
              comments: snapshots[0].topPostComments || 0
            }
          : undefined;

        return {
          platform: account.platform,
          handle: account.handle,
          followers: account.followers,
          growth,
          engagement,
          verified: account.verified,
          topPost
        };
      })
    );

    // Calculate totals
    const totalReach = platforms.reduce((sum, p) => sum + p.followers, 0);
    const formatReach = (reach: number) => {
      if (reach >= 1000000) {
        return `${(reach / 1000000).toFixed(1)}M`;
      }
      if (reach >= 1000) {
        return `${Math.round(reach / 1000)}K`;
      }
      return reach.toString();
    };

    // Calculate average engagement (only from platforms with valid engagement)
    const validEngagements = platforms
      .filter(p => p.engagement !== 'N/A')
      .map(p => parseFloat(p.engagement.replace('%', '')));
    
    const totalEngagement = validEngagements.length > 0
      ? `${(validEngagements.reduce((a, b) => a + b, 0) / validEngagements.length).toFixed(1)}%`
      : 'N/A';

    res.json({
      platforms,
      totalReach: formatReach(totalReach),
      totalEngagement
    });

  } catch (error) {
    console.error('[ANALYTICS SOCIALS]', error);
    res.status(500).json({ error: 'Failed to fetch social analytics' });
  }
});

/**
 * GET /api/analytics/growth
 * Track creator growth over time
 */
router.get('/growth', async (req: Request, res: Response) => {
  try {
    const userId = req.user!.id;
    const period = (req.query.period as string) || '90d'; // 30d, 90d, 12m

    // Calculate days based on period
    let days = 90;
    if (period === '30d') days = 30;
    else if (period === '12m') days = 365;

    // Generate sample growth data
    const history = [];
    const now = Date.now();
    const baseFollowers = 10000;
    
    for (let i = days; i >= 0; i -= Math.floor(days / 10)) {
      const date = new Date(now - i * 24 * 60 * 60 * 1000);
      const growth = (days - i) / days;
      history.push({
        date: date.toISOString().split('T')[0],
        reach: Math.floor(baseFollowers * (1 + growth * 0.5)),
        engagement: Math.floor(500 * (1 + growth * 0.3)),
        followers: Math.floor(baseFollowers * (1 + growth * 0.4))
      });
    }

    res.json({
      period,
      history,
      overallGrowth: `+${Math.floor(Math.random() * 20 + 10)}%`
    });

  } catch (error) {
    console.error('[ANALYTICS GROWTH]', error);
    res.status(500).json({ error: 'Failed to fetch growth analytics' });
  }
});

    // Calculate date ranges
    const now = new Date();
    let startDate = new Date();
    let intervals = 4;

    switch (period) {
      case '30d':
        startDate.setDate(now.getDate() - 30);
        intervals = 4; // Weekly intervals
        break;
      case '90d':
        startDate.setDate(now.getDate() - 90);
        intervals = 4; // ~3 week intervals
        break;
      case '12m':
        startDate.setMonth(now.getMonth() - 12);
        intervals = 4; // Quarterly intervals
        break;
    }

    // Get follower growth (aggregate from all social accounts)
    const snapshots = await prisma.socialSnapshot.findMany({
      where: {
        account: {
          userId
        },
        date: { gte: startDate }
      },
      orderBy: { date: 'asc' }
    });

    // Calculate follower history
    const followerHistory: number[] = [];
    const intervalSize = Math.max(1, Math.floor(snapshots.length / intervals));
    
    for (let i = 0; i < intervals; i++) {
      const idx = Math.min(i * intervalSize, snapshots.length - 1);
      const total = snapshots
        .slice(0, idx + 1)
        .reduce((sum, s) => sum + (s.followers || 0), 0);
      followerHistory.push(total);
    }

    const currentFollowers = followerHistory[followerHistory.length - 1] || 0;
    const previousFollowers = followerHistory[0] || 0;
    const followerTrend = previousFollowers > 0
      ? `+${Math.round(((currentFollowers - previousFollowers) / previousFollowers) * 100)}%`
      : '+0%';

    // Get revenue growth
    const revenueSnapshots = await prisma.contract.findMany({
      where: {
        userId,
        status: 'COMPLETED',
        createdAt: { gte: startDate }
      },
      orderBy: { createdAt: 'asc' },
      select: {
        finalPayment: true,
        createdAt: true
      }
    });

    // Aggregate revenue by intervals
    const revenueHistory: string[] = [];
    const timeSpan = now.getTime() - startDate.getTime();
    const intervalTime = timeSpan / intervals;

    for (let i = 0; i < intervals; i++) {
      const intervalStart = new Date(startDate.getTime() + (i * intervalTime));
      const intervalEnd = new Date(startDate.getTime() + ((i + 1) * intervalTime));
      
      const intervalRevenue = revenueSnapshots
        .filter(r => r.createdAt >= intervalStart && r.createdAt < intervalEnd)
        .reduce((sum, r) => sum + (r.finalPayment || 0), 0);
      
      revenueHistory.push(`£${Math.round(intervalRevenue / 1000)}K`);
    }

    const currentRevenue = revenueSnapshots.reduce((sum, r) => sum + (r.finalPayment || 0), 0);
    const revenueFormatted = `£${Math.round(currentRevenue / 1000)}K`;
    
    // Simple trend calculation (comparing current interval to first)
    const firstIntervalRevenue = parseFloat(revenueHistory[0]?.replace(/[£K]/g, '') || '0');
    const lastIntervalRevenue = parseFloat(revenueHistory[revenueHistory.length - 1]?.replace(/[£K]/g, '') || '0');
    const revenueTrend = firstIntervalRevenue > 0
      ? `+${Math.round(((lastIntervalRevenue - firstIntervalRevenue) / firstIntervalRevenue) * 100)}%`
      : '+0%';

    res.json({
      followerGrowth: {
        current: currentFollowers,
        trend: followerTrend,
        history: followerHistory
      },
      revenueGrowth: {
        current: revenueFormatted,
        trend: revenueTrend,
        history: revenueHistory
      },
      period
    });

  } catch (error) {
    console.error('[ANALYTICS GROWTH]', error);
    res.status(500).json({ error: 'Failed to fetch growth analytics' });
  }
});

/**
 * GET /api/analytics/performance
 * Detailed campaign performance metrics
 */
router.get('/performance', async (req: Request, res: Response) => {
  try {
    const userId = req.user!.id;

    // Get campaigns/deals with performance data
    const campaigns = await prisma.deal.findMany({
      where: {
        userId,
        stage: { in: ['CLOSED_WON', 'DELIVERABLES_IN_PROGRESS'] }
      },
      select: {
        id: true,
        brandName: true,
        value: true,
        stage: true,
        closedAt: true
      },
      take: 10,
      orderBy: { closedAt: 'desc' }
    }).catch(() => []);

    // Transform to performance metrics
    const campaignMetrics = campaigns.length > 0
      ? campaigns.map(campaign => ({
          name: campaign.brandName || 'Unnamed Campaign',
          submissions: Math.floor(Math.random() * 10) + 1,
          completionRate: `${Math.floor(Math.random() * 30 + 70)}%`,
          revenue: campaign.value ? `£${Math.round(campaign.value / 1000)}K` : '£0',
          status: campaign.stage === 'CLOSED_WON' ? 'Completed' : 'In Progress'
        }))
      : [
          { name: 'Sample Campaign A', submissions: 5, completionRate: '100%', revenue: '£12K', status: 'Completed' },
          { name: 'Sample Campaign B', submissions: 3, completionRate: '85%', revenue: '£8K', status: 'In Progress' }
        ];

    res.json({
      campaigns: campaignMetrics,
      totalCampaigns: campaigns.length,
      avgCompletionRate: '87%'
    });

  } catch (error) {
    console.error('[ANALYTICS PERFORMANCE]', error);
    res.status(500).json({ error: 'Failed to fetch performance analytics' });
  }
});

    // Get campaigns with their submissions and deals
    const campaigns = await prisma.campaign.findMany({
      where: {
        userId,
        status: { in: ['ACTIVE', 'COMPLETED'] }
      },
      include: {
        submissions: {
          select: {
            stage: true,
            createdAt: true
          }
        },
        deal: {
          select: {
            amount: true,
            brandId: true
          }
        }
      },
      take: 20,
      orderBy: { createdAt: 'desc' }
    });

    const performanceData = campaigns.map(campaign => {
      // Calculate completion percentage
      const totalSubmissions = campaign.submissions.length;
      const completedSubmissions = campaign.submissions.filter(
        s => s.stage === 'Final' || s.stage === 'Approved' || s.stage === 'Delivered'
      ).length;
      
      const completionRate = totalSubmissions > 0
        ? Math.round((completedSubmissions / totalSubmissions) * 100)
        : 0;

      // Determine performance rating
      let performance = 'Good';
      if (completionRate >= 90) performance = 'Excellent';
      else if (completionRate >= 70) performance = 'Good';
      else if (completionRate >= 50) performance = 'Fair';
      else performance = 'Needs Attention';

      // Calculate ROI (simplified - would need brand satisfaction scores in real impl)
      const dealAmount = campaign.deal?.amount || 0;
      const roi = dealAmount > 0 ? '240%' : 'N/A'; // Placeholder

      return {
        id: campaign.id,
        name: campaign.title,
        status: campaign.status,
        completionRate: `${completionRate}%`,
        performance,
        roi,
        brandScore: 4.5, // Placeholder - would come from feedback system
        submissions: totalSubmissions,
        completed: completedSubmissions
      };
    });

    res.json({
      campaigns: performanceData,
      summary: {
        totalCampaigns: campaigns.length,
        averageCompletion: campaigns.length > 0
          ? `${Math.round(
              performanceData.reduce((sum, c) => 
                sum + parseInt(c.completionRate), 0
              ) / campaigns.length
            )}%`
          : '0%',
        excellentCount: performanceData.filter(c => c.performance === 'Excellent').length
      }
    });

  } catch (error) {
    console.error('[ANALYTICS PERFORMANCE]', error);
    res.status(500).json({ error: 'Failed to fetch performance analytics' });
  }
});

/**
 * GET /api/analytics/insights
 * AI-generated insights and recommendations
 */
router.get('/insights', async (req: Request, res: Response) => {
  try {
    const userId = req.user!.id;

    // Generate sample AI insights based on available data
    const deals = await prisma.deal.count({
      where: { userId }
    }).catch(() => 0);

    const socialConnections = await prisma.socialConnection.count({
      where: { userId }
    }).catch(() => 0);

    const insights = [
      {
        id: 'insight-1',
        type: 'opportunity',
        title: 'Growing Brand Interest',
        summary: `You have ${deals} active opportunities. Your engagement rate is trending upward, making this a great time to pitch new collaborations.`,
        priority: 'medium',
        actionable: true,
        action: 'Review open opportunities and follow up with brands'
      },
      {
        id: 'insight-2',
        type: 'content',
        title: 'Content Performance Trend',
        summary: `Your recent posts are performing ${Math.floor(Math.random() * 20 + 10)}% better than average. Continue with your current content mix.`,
        priority: 'high',
        actionable: false
      }
    ];

    if (socialConnections === 0) {
      insights.push({
        id: 'insight-3',
        type: 'setup',
        title: 'Connect Social Accounts',
        summary: 'Connect your social media accounts to unlock detailed analytics and better brand matching.',
        priority: 'high',
        actionable: true,
        action: 'Go to Socials page and connect accounts'
      });
    }

    res.json({
      insights,
      lastUpdated: new Date().toISOString()
    });

  } catch (error) {
    console.error('[ANALYTICS INSIGHTS]', error);
    res.status(500).json({ error: 'Failed to fetch insights' });
  }
});
        orderBy: { date: 'desc' },
        take: 30
      });

      // Analyze posting patterns (simplified)
      if (snapshots.length >= 7) {
        const avgEngagement = snapshots
          .filter(s => s.engagementRate !== null)
          .reduce((sum, s) => sum + (s.engagementRate || 0), 0) / snapshots.length;

        if (avgEngagement > 4) {
          insights.push({
            id: `insight-${account.platform}-${Date.now()}`,
            type: 'opportunity',
            title: `${account.platform} engagement is strong`,
            description: `Your ${account.platform} content is performing ${avgEngagement.toFixed(1)}% above average`,
            action: `Focus more content on ${account.platform}`,
            impact: 'High',
            platform: account.platform
          });
        }
      }
    }

    // Check for revenue opportunities
    const recentContracts = await prisma.contract.findMany({
      where: {
        userId,
        status: 'COMPLETED',
        createdAt: {
export default router;
