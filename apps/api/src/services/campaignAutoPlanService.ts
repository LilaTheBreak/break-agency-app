import prisma from "../lib/prisma.js";
import { runCampaignLLM } from "./ai/campaignLLM.js";
import * as campaignBuilderService from "./campaignBuilderService.js";
import * as campaignForecastService from "./campaignForecastService.js";
import * as creativeDirectionService from "./creativeDirectionService.js";
import * as contentStrategyService from "./contentStrategyService.js";
import * as campaignDeliverableService from "./campaignDeliverableService.js";
import * as storyboardService from "./storyboardService.js";
import * as hashtagService from "./hashtagService.js";
import * as postingSchedulerService from "./postingSchedulerService.js";

interface AutoPlanInput {
  dealId?: string;
  briefId?: string;
  userId: string;
}

/**
 * Orchestrates the automatic generation of a complete campaign plan.
 * @param input - The deal or brief ID to base the plan on.
 * @returns A comprehensive campaign plan.
 */
export async function autoPlanCampaign(input: AutoPlanInput) {
  const { dealId, briefId, userId } = input;

  let brief: any;
  let deal: any;
  let brand: any;
  let talent: any;

  if (dealId) {
    deal = await prisma.deal.findUnique({ where: { id: dealId }, include: { talent: true } });
    if (!deal) throw new Error("Deal not found.");
    brief = await prisma.brandBrief.findFirst({ where: { campaignId: deal.campaignId } }); // Assuming deal links to campaign, which links to brief
    brand = await prisma.brand.findUnique({ where: { id: deal.brandId } });
    talent = deal.talent;
  } else if (briefId) {
    brief = await prisma.brandBrief.findUnique({ where: { id: briefId }, include: { campaign: true } });
    if (!brief) throw new Error("Brief not found.");
    deal = await prisma.deal.findFirst({ where: { campaignId: brief.campaignId } });
    brand = brief.campaign ? await prisma.brand.findUnique({ where: { id: brief.campaign.brandId } }) : null;
    talent = deal ? await prisma.talent.findUnique({ where: { id: deal.talentId } }) : null;
  } else {
    throw new Error("Either dealId or briefId must be provided.");
  }

  if (!brief || !brand || !talent) {
    throw new Error("Insufficient data to generate campaign plan (missing brief, brand, or talent).");
  }

  const llmInput = { brief, brandProfile: brand, talentProfile: talent };

  // Generate all components concurrently
  const [
    concepts,
    deliverables,
    timeline,
    forecast,
    creativeDirection,
    storyboard,
    hashtags,
    postingSchedule,
  ] = await Promise.all([
    runCampaignLLM(llmInput, "generate_concepts").then(res => res.data.concepts),
    campaignDeliverableService.generateCampaignDeliverables(llmInput),
    runCampaignLLM(llmInput, "generate_timeline").then(res => res.data.timeline),
    campaignForecastService.generateCampaignForecast(llmInput),
    creativeDirectionService.generateCreativeDirection(llmInput),
    storyboardService.generateStoryboard(llmInput),
    hashtagService.generateHashtags(llmInput),
    postingSchedulerService.generatePostingSchedule(llmInput),
  ]);

  // Create/Update the BrandCampaign record
  const campaign = await prisma.brandCampaign.upsert({
    where: { id: brief.campaignId },
    update: {
      autoGenerated: true,
      rawAiPlan: {
        concepts, deliverables, timeline, forecast, creativeDirection, storyboard, hashtags, postingSchedule,
      },
      timeline: timeline,
      forecast: forecast,
      creativeDirection: {
        upsert: {
          create: creativeDirection,
          update: creativeDirection,
        },
      },
      // Deliverables, content strategy, etc. would be created/updated here
    },
    create: {
      // This path should ideally be handled by campaignBuilderService.generateCampaign
      // This upsert is mainly for updating an existing campaign's auto-plan
      userId,
      title: `Auto-Plan for ${brand.name} x ${talent.name}`,
      brief: { connect: { id: brief.id } },
      autoGenerated: true,
      rawAiPlan: { concepts, deliverables, timeline, forecast, creativeDirection, storyboard, hashtags, postingSchedule },
      timeline: timeline,
      forecast: forecast,
      creativeDirection: { create: creativeDirection },
    },
  });

  return { campaignId: campaign.id, concepts, deliverables, timeline, forecast, creativeDirection, storyboard, hashtags, postingSchedule };
}